// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reminders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createReminder = `-- name: CreateReminder :one
INSERT INTO reminders (
    user_id, title, description, scheduled_at, reminder_type, 
    notification_channels, scheduled_time, scheduled_days_of_week, 
    delivery_window_minutes, delivery_method, delivery_address, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, user_id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active
`

type CreateReminderParams struct {
	UserID                string             `json:"user_id"`
	Title                 string             `json:"title"`
	Description           pgtype.Text        `json:"description"`
	ScheduledAt           pgtype.Timestamptz `json:"scheduled_at"`
	ReminderType          string             `json:"reminder_type"`
	NotificationChannels  []byte             `json:"notification_channels"`
	ScheduledTime         pgtype.Time        `json:"scheduled_time"`
	ScheduledDaysOfWeek   []int32            `json:"scheduled_days_of_week"`
	DeliveryWindowMinutes int32              `json:"delivery_window_minutes"`
	DeliveryMethod        string             `json:"delivery_method"`
	DeliveryAddress       string             `json:"delivery_address"`
	IsActive              bool               `json:"is_active"`
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.ScheduledAt,
		arg.ReminderType,
		arg.NotificationChannels,
		arg.ScheduledTime,
		arg.ScheduledDaysOfWeek,
		arg.DeliveryWindowMinutes,
		arg.DeliveryMethod,
		arg.DeliveryAddress,
		arg.IsActive,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
	)
	return i, err
}

const deleteReminder = `-- name: DeleteReminder :exec
UPDATE reminders SET 
    is_active = false,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteReminder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteReminder, id)
	return err
}

const getActiveReminders = `-- name: GetActiveReminders :many
SELECT id, user_id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active FROM reminders 
WHERE is_active = true AND status = 'pending'
ORDER BY scheduled_at ASC
`

func (q *Queries) GetActiveReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getActiveReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringReminders = `-- name: GetRecurringReminders :many
SELECT id, user_id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active FROM reminders 
WHERE reminder_type = 'persistent'
  AND is_active = true
  AND (
    EXTRACT(DOW FROM NOW()) = ANY(scheduled_days_of_week)
    OR scheduled_days_of_week IS NULL
  )
`

func (q *Queries) GetRecurringReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRecurringReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReminder = `-- name: GetReminder :one
SELECT id, user_id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active FROM reminders WHERE id = $1
`

func (q *Queries) GetReminder(ctx context.Context, id int32) (Reminder, error) {
	row := q.db.QueryRow(ctx, getReminder, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
	)
	return i, err
}

const getRemindersByUser = `-- name: GetRemindersByUser :many
SELECT id, user_id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active FROM reminders 
WHERE user_id = $1 AND is_active = true 
ORDER BY scheduled_at ASC
`

func (q *Queries) GetRemindersByUser(ctx context.Context, userID string) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemindersDueForDelivery = `-- name: GetRemindersDueForDelivery :many
SELECT id, user_id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active FROM reminders 
WHERE is_active = true 
  AND status = 'pending'
  AND scheduled_at <= NOW() + INTERVAL '1 minute' * delivery_window_minutes
  AND scheduled_at >= NOW() - INTERVAL '1 minute' * delivery_window_minutes
`

func (q *Queries) GetRemindersDueForDelivery(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersDueForDelivery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReminder = `-- name: UpdateReminder :one
UPDATE reminders SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    scheduled_at = COALESCE($4, scheduled_at),
    reminder_type = COALESCE($5, reminder_type),
    notification_channels = COALESCE($6, notification_channels),
    scheduled_time = COALESCE($7, scheduled_time),
    scheduled_days_of_week = COALESCE($8, scheduled_days_of_week),
    delivery_window_minutes = COALESCE($9, delivery_window_minutes),
    delivery_method = COALESCE($10, delivery_method),
    delivery_address = COALESCE($11, delivery_address),
    is_active = COALESCE($12, is_active),
    updated_at = NOW()
WHERE id = $1 RETURNING id, user_id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active
`

type UpdateReminderParams struct {
	ID                    int32              `json:"id"`
	Title                 string             `json:"title"`
	Description           pgtype.Text        `json:"description"`
	ScheduledAt           pgtype.Timestamptz `json:"scheduled_at"`
	ReminderType          string             `json:"reminder_type"`
	NotificationChannels  []byte             `json:"notification_channels"`
	ScheduledTime         pgtype.Time        `json:"scheduled_time"`
	ScheduledDaysOfWeek   []int32            `json:"scheduled_days_of_week"`
	DeliveryWindowMinutes int32              `json:"delivery_window_minutes"`
	DeliveryMethod        string             `json:"delivery_method"`
	DeliveryAddress       string             `json:"delivery_address"`
	IsActive              bool               `json:"is_active"`
}

func (q *Queries) UpdateReminder(ctx context.Context, arg UpdateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, updateReminder,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ScheduledAt,
		arg.ReminderType,
		arg.NotificationChannels,
		arg.ScheduledTime,
		arg.ScheduledDaysOfWeek,
		arg.DeliveryWindowMinutes,
		arg.DeliveryMethod,
		arg.DeliveryAddress,
		arg.IsActive,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
	)
	return i, err
}

const updateReminderStatus = `-- name: UpdateReminderStatus :exec
UPDATE reminders SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReminderStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateReminderStatus(ctx context.Context, arg UpdateReminderStatusParams) error {
	_, err := q.db.Exec(ctx, updateReminderStatus, arg.ID, arg.Status)
	return err
}
