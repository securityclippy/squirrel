// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reminders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acknowledgeReminder = `-- name: AcknowledgeReminder :exec
UPDATE reminders SET 
    acknowledged_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) AcknowledgeReminder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, acknowledgeReminder, id)
	return err
}

const createReminder = `-- name: CreateReminder :one
INSERT INTO reminders (
    user_id, title, description, scheduled_at, reminder_type, 
    notification_channels, scheduled_time, scheduled_days_of_week, 
    delivery_window_minutes, delivery_method, delivery_address, is_active,
    is_persistent, reminder_interval_minutes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id
`

type CreateReminderParams struct {
	UserID                  int32              `json:"user_id"`
	Title                   string             `json:"title"`
	Description             pgtype.Text        `json:"description"`
	ScheduledAt             pgtype.Timestamptz `json:"scheduled_at"`
	ReminderType            string             `json:"reminder_type"`
	NotificationChannels    []byte             `json:"notification_channels"`
	ScheduledTime           pgtype.Time        `json:"scheduled_time"`
	ScheduledDaysOfWeek     []int32            `json:"scheduled_days_of_week"`
	DeliveryWindowMinutes   int32              `json:"delivery_window_minutes"`
	DeliveryMethod          string             `json:"delivery_method"`
	DeliveryAddress         string             `json:"delivery_address"`
	IsActive                bool               `json:"is_active"`
	IsPersistent            bool               `json:"is_persistent"`
	ReminderIntervalMinutes pgtype.Int4        `json:"reminder_interval_minutes"`
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.ScheduledAt,
		arg.ReminderType,
		arg.NotificationChannels,
		arg.ScheduledTime,
		arg.ScheduledDaysOfWeek,
		arg.DeliveryWindowMinutes,
		arg.DeliveryMethod,
		arg.DeliveryAddress,
		arg.IsActive,
		arg.IsPersistent,
		arg.ReminderIntervalMinutes,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
		&i.IsPersistent,
		&i.AcknowledgedAt,
		&i.ReminderIntervalMinutes,
		&i.LastRemindedAt,
		&i.UserID,
	)
	return i, err
}

const deleteReminder = `-- name: DeleteReminder :exec
UPDATE reminders SET 
    is_active = false,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteReminder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteReminder, id)
	return err
}

const getActiveReminders = `-- name: GetActiveReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id FROM reminders 
WHERE is_active = true AND status = 'pending'
ORDER BY scheduled_at ASC
`

func (q *Queries) GetActiveReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getActiveReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRecurringReminders = `-- name: GetPendingRecurringReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id FROM reminders 
WHERE reminder_type = 'recurring'
  AND is_active = true
  AND status = 'pending'
  AND scheduled_time <= NOW()::time
  AND (
    scheduled_days_of_week IS NULL
    OR EXTRACT(DOW FROM NOW()) = ANY(scheduled_days_of_week)
  )
`

func (q *Queries) GetPendingRecurringReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getPendingRecurringReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringReminders = `-- name: GetRecurringReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id FROM reminders 
WHERE reminder_type IN ('persistent', 'recurring')
  AND is_active = true
  AND (
    EXTRACT(DOW FROM NOW()) = ANY(scheduled_days_of_week)
    OR scheduled_days_of_week IS NULL
  )
`

func (q *Queries) GetRecurringReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRecurringReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReminder = `-- name: GetReminder :one
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id FROM reminders WHERE id = $1
`

func (q *Queries) GetReminder(ctx context.Context, id int32) (Reminder, error) {
	row := q.db.QueryRow(ctx, getReminder, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
		&i.IsPersistent,
		&i.AcknowledgedAt,
		&i.ReminderIntervalMinutes,
		&i.LastRemindedAt,
		&i.UserID,
	)
	return i, err
}

const getRemindersByUser = `-- name: GetRemindersByUser :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id FROM reminders 
WHERE user_id = $1 AND is_active = true 
ORDER BY scheduled_at ASC
`

func (q *Queries) GetRemindersByUser(ctx context.Context, userID int32) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemindersDueForDelivery = `-- name: GetRemindersDueForDelivery :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id FROM reminders 
WHERE is_active = true 
  AND status = 'pending'
  AND scheduled_at <= NOW() + INTERVAL '1 minute' * delivery_window_minutes
  AND scheduled_at >= NOW() - INTERVAL '1 minute' * delivery_window_minutes
`

func (q *Queries) GetRemindersDueForDelivery(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersDueForDelivery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnacknowledgedPersistentReminders = `-- name: GetUnacknowledgedPersistentReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id FROM reminders 
WHERE is_persistent = true 
  AND is_active = true
  AND acknowledged_at IS NULL
  AND (
    last_reminded_at IS NULL 
    OR last_reminded_at < NOW() - INTERVAL '1 minute' * reminder_interval_minutes
  )
`

func (q *Queries) GetUnacknowledgedPersistentReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getUnacknowledgedPersistentReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLastRemindedAt = `-- name: UpdateLastRemindedAt :exec
UPDATE reminders SET 
    last_reminded_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateLastRemindedAt(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateLastRemindedAt, id)
	return err
}

const updateReminder = `-- name: UpdateReminder :one
UPDATE reminders SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    scheduled_at = COALESCE($4, scheduled_at),
    reminder_type = COALESCE($5, reminder_type),
    notification_channels = COALESCE($6, notification_channels),
    scheduled_time = COALESCE($7, scheduled_time),
    scheduled_days_of_week = COALESCE($8, scheduled_days_of_week),
    delivery_window_minutes = COALESCE($9, delivery_window_minutes),
    delivery_method = COALESCE($10, delivery_method),
    delivery_address = COALESCE($11, delivery_address),
    is_active = COALESCE($12, is_active),
    is_persistent = COALESCE($13, is_persistent),
    reminder_interval_minutes = COALESCE($14, reminder_interval_minutes),
    updated_at = NOW()
WHERE id = $1 RETURNING id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id
`

type UpdateReminderParams struct {
	ID                      int32              `json:"id"`
	Title                   string             `json:"title"`
	Description             pgtype.Text        `json:"description"`
	ScheduledAt             pgtype.Timestamptz `json:"scheduled_at"`
	ReminderType            string             `json:"reminder_type"`
	NotificationChannels    []byte             `json:"notification_channels"`
	ScheduledTime           pgtype.Time        `json:"scheduled_time"`
	ScheduledDaysOfWeek     []int32            `json:"scheduled_days_of_week"`
	DeliveryWindowMinutes   int32              `json:"delivery_window_minutes"`
	DeliveryMethod          string             `json:"delivery_method"`
	DeliveryAddress         string             `json:"delivery_address"`
	IsActive                bool               `json:"is_active"`
	IsPersistent            bool               `json:"is_persistent"`
	ReminderIntervalMinutes pgtype.Int4        `json:"reminder_interval_minutes"`
}

func (q *Queries) UpdateReminder(ctx context.Context, arg UpdateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, updateReminder,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ScheduledAt,
		arg.ReminderType,
		arg.NotificationChannels,
		arg.ScheduledTime,
		arg.ScheduledDaysOfWeek,
		arg.DeliveryWindowMinutes,
		arg.DeliveryMethod,
		arg.DeliveryAddress,
		arg.IsActive,
		arg.IsPersistent,
		arg.ReminderIntervalMinutes,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
		&i.IsPersistent,
		&i.AcknowledgedAt,
		&i.ReminderIntervalMinutes,
		&i.LastRemindedAt,
		&i.UserID,
	)
	return i, err
}

const updateReminderStatus = `-- name: UpdateReminderStatus :exec
UPDATE reminders SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReminderStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateReminderStatus(ctx context.Context, arg UpdateReminderStatusParams) error {
	_, err := q.db.Exec(ctx, updateReminderStatus, arg.ID, arg.Status)
	return err
}
