// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reminders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acknowledgeReminder = `-- name: AcknowledgeReminder :exec
UPDATE reminders SET 
    acknowledged_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) AcknowledgeReminder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, acknowledgeReminder, id)
	return err
}

const completeReminder = `-- name: CompleteReminder :exec
UPDATE reminders SET 
    status = 'completed',
    completed_at = NOW(),
    completion_note = $2,
    updated_at = NOW()
WHERE id = $1
`

type CompleteReminderParams struct {
	ID             int32       `json:"id"`
	CompletionNote pgtype.Text `json:"completion_note"`
}

func (q *Queries) CompleteReminder(ctx context.Context, arg CompleteReminderParams) error {
	_, err := q.db.Exec(ctx, completeReminder, arg.ID, arg.CompletionNote)
	return err
}

const createReminder = `-- name: CreateReminder :one
INSERT INTO reminders (
    user_id, title, description, scheduled_at, reminder_type, 
    notification_channels, scheduled_time, scheduled_days_of_week, 
    delivery_window_minutes, delivery_method, delivery_address, is_active,
    is_persistent, reminder_interval_minutes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note
`

type CreateReminderParams struct {
	UserID                  int32              `json:"user_id"`
	Title                   string             `json:"title"`
	Description             pgtype.Text        `json:"description"`
	ScheduledAt             pgtype.Timestamptz `json:"scheduled_at"`
	ReminderType            string             `json:"reminder_type"`
	NotificationChannels    []byte             `json:"notification_channels"`
	ScheduledTime           pgtype.Time        `json:"scheduled_time"`
	ScheduledDaysOfWeek     []int32            `json:"scheduled_days_of_week"`
	DeliveryWindowMinutes   int32              `json:"delivery_window_minutes"`
	DeliveryMethod          string             `json:"delivery_method"`
	DeliveryAddress         string             `json:"delivery_address"`
	IsActive                bool               `json:"is_active"`
	IsPersistent            bool               `json:"is_persistent"`
	ReminderIntervalMinutes pgtype.Int4        `json:"reminder_interval_minutes"`
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.ScheduledAt,
		arg.ReminderType,
		arg.NotificationChannels,
		arg.ScheduledTime,
		arg.ScheduledDaysOfWeek,
		arg.DeliveryWindowMinutes,
		arg.DeliveryMethod,
		arg.DeliveryAddress,
		arg.IsActive,
		arg.IsPersistent,
		arg.ReminderIntervalMinutes,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
		&i.IsPersistent,
		&i.AcknowledgedAt,
		&i.ReminderIntervalMinutes,
		&i.LastRemindedAt,
		&i.UserID,
		&i.Category,
		&i.CompletedAt,
		&i.CompletionNote,
	)
	return i, err
}

const deleteReminder = `-- name: DeleteReminder :exec
UPDATE reminders SET 
    is_active = false,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteReminder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteReminder, id)
	return err
}

const getActiveReminders = `-- name: GetActiveReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note FROM reminders 
WHERE is_active = true AND status = 'pending'
ORDER BY scheduled_at ASC
`

func (q *Queries) GetActiveReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getActiveReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
			&i.Category,
			&i.CompletedAt,
			&i.CompletionNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRecurringReminders = `-- name: GetPendingRecurringReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note FROM reminders 
WHERE reminder_type = 'recurring'
  AND is_active = true
  AND status = 'pending'
  AND scheduled_time <= NOW()::time
  AND (
    scheduled_days_of_week IS NULL
    OR EXTRACT(DOW FROM NOW()) = ANY(scheduled_days_of_week)
  )
`

func (q *Queries) GetPendingRecurringReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getPendingRecurringReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
			&i.Category,
			&i.CompletedAt,
			&i.CompletionNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringReminders = `-- name: GetRecurringReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note FROM reminders 
WHERE reminder_type IN ('persistent', 'recurring')
  AND is_active = true
  AND (
    EXTRACT(DOW FROM NOW()) = ANY(scheduled_days_of_week)
    OR scheduled_days_of_week IS NULL
  )
`

func (q *Queries) GetRecurringReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRecurringReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
			&i.Category,
			&i.CompletedAt,
			&i.CompletionNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReminder = `-- name: GetReminder :one
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note FROM reminders WHERE id = $1
`

func (q *Queries) GetReminder(ctx context.Context, id int32) (Reminder, error) {
	row := q.db.QueryRow(ctx, getReminder, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
		&i.IsPersistent,
		&i.AcknowledgedAt,
		&i.ReminderIntervalMinutes,
		&i.LastRemindedAt,
		&i.UserID,
		&i.Category,
		&i.CompletedAt,
		&i.CompletionNote,
	)
	return i, err
}

const getRemindersByUser = `-- name: GetRemindersByUser :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note FROM reminders 
WHERE user_id = $1 AND is_active = true 
ORDER BY scheduled_at ASC
`

func (q *Queries) GetRemindersByUser(ctx context.Context, userID int32) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
			&i.Category,
			&i.CompletedAt,
			&i.CompletionNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemindersDueForDelivery = `-- name: GetRemindersDueForDelivery :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note FROM reminders 
WHERE is_active = true 
  AND status = 'pending'
  AND scheduled_at <= NOW() + INTERVAL '1 minute' * delivery_window_minutes
  AND scheduled_at >= NOW() - INTERVAL '1 minute' * delivery_window_minutes
`

func (q *Queries) GetRemindersDueForDelivery(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersDueForDelivery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
			&i.Category,
			&i.CompletedAt,
			&i.CompletionNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnacknowledgedPersistentReminders = `-- name: GetUnacknowledgedPersistentReminders :many
SELECT id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note FROM reminders 
WHERE is_persistent = true 
  AND is_active = true
  AND acknowledged_at IS NULL
  AND (
    last_reminded_at IS NULL 
    OR last_reminded_at < NOW() - INTERVAL '1 minute' * reminder_interval_minutes
  )
`

func (q *Queries) GetUnacknowledgedPersistentReminders(ctx context.Context) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getUnacknowledgedPersistentReminders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveryMethod,
			&i.DeliveryAddress,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderType,
			&i.NotificationChannels,
			&i.ScheduledTime,
			&i.ScheduledDaysOfWeek,
			&i.DeliveryWindowMinutes,
			&i.IsActive,
			&i.IsPersistent,
			&i.AcknowledgedAt,
			&i.ReminderIntervalMinutes,
			&i.LastRemindedAt,
			&i.UserID,
			&i.Category,
			&i.CompletedAt,
			&i.CompletionNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCategoryStats = `-- name: GetUserCategoryStats :many
SELECT 
    category,
    COUNT(*) as count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 0) as percentage
FROM reminders 
WHERE user_id = $1
GROUP BY category
ORDER BY count DESC
`

type GetUserCategoryStatsRow struct {
	Category   string         `json:"category"`
	Count      int64          `json:"count"`
	Percentage pgtype.Numeric `json:"percentage"`
}

func (q *Queries) GetUserCategoryStats(ctx context.Context, userID int32) ([]GetUserCategoryStatsRow, error) {
	rows, err := q.db.Query(ctx, getUserCategoryStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCategoryStatsRow{}
	for rows.Next() {
		var i GetUserCategoryStatsRow
		if err := rows.Scan(&i.Category, &i.Count, &i.Percentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMonthlyStats = `-- name: GetUserMonthlyStats :one
SELECT 
    COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '1 month' THEN 1 END) as this_month,
    COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '2 months' AND created_at < CURRENT_DATE - INTERVAL '1 month' THEN 1 END) as last_month
FROM reminders 
WHERE user_id = $1
`

type GetUserMonthlyStatsRow struct {
	ThisMonth int64 `json:"this_month"`
	LastMonth int64 `json:"last_month"`
}

func (q *Queries) GetUserMonthlyStats(ctx context.Context, userID int32) (GetUserMonthlyStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserMonthlyStats, userID)
	var i GetUserMonthlyStatsRow
	err := row.Scan(&i.ThisMonth, &i.LastMonth)
	return i, err
}

const getUserOverviewStats = `-- name: GetUserOverviewStats :one
SELECT 
    COUNT(*) as total_reminders,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_reminders,
    COUNT(CASE WHEN status NOT IN ('completed', 'cancelled', 'failed') THEN 1 END) as active_reminders,
    MIN(created_at) as member_since
FROM reminders 
WHERE user_id = $1
`

type GetUserOverviewStatsRow struct {
	TotalReminders     int64       `json:"total_reminders"`
	CompletedReminders int64       `json:"completed_reminders"`
	ActiveReminders    int64       `json:"active_reminders"`
	MemberSince        interface{} `json:"member_since"`
}

func (q *Queries) GetUserOverviewStats(ctx context.Context, userID int32) (GetUserOverviewStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserOverviewStats, userID)
	var i GetUserOverviewStatsRow
	err := row.Scan(
		&i.TotalReminders,
		&i.CompletedReminders,
		&i.ActiveReminders,
		&i.MemberSince,
	)
	return i, err
}

const getUserStatistics = `-- name: GetUserStatistics :one
SELECT user_id, total_reminders, completed_reminders, active_reminders, this_week_count, last_week_count, this_month_count, last_month_count, weekly_change_percent, monthly_change_percent, category_breakdown FROM reminder_statistics WHERE user_id = $1
`

func (q *Queries) GetUserStatistics(ctx context.Context, userID int32) (ReminderStatistic, error) {
	row := q.db.QueryRow(ctx, getUserStatistics, userID)
	var i ReminderStatistic
	err := row.Scan(
		&i.UserID,
		&i.TotalReminders,
		&i.CompletedReminders,
		&i.ActiveReminders,
		&i.ThisWeekCount,
		&i.LastWeekCount,
		&i.ThisMonthCount,
		&i.LastMonthCount,
		&i.WeeklyChangePercent,
		&i.MonthlyChangePercent,
		&i.CategoryBreakdown,
	)
	return i, err
}

const getUserWeeklyStats = `-- name: GetUserWeeklyStats :one
SELECT 
    COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 END) as this_week,
    COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '14 days' AND created_at < CURRENT_DATE - INTERVAL '7 days' THEN 1 END) as last_week
FROM reminders 
WHERE user_id = $1
`

type GetUserWeeklyStatsRow struct {
	ThisWeek int64 `json:"this_week"`
	LastWeek int64 `json:"last_week"`
}

func (q *Queries) GetUserWeeklyStats(ctx context.Context, userID int32) (GetUserWeeklyStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserWeeklyStats, userID)
	var i GetUserWeeklyStatsRow
	err := row.Scan(&i.ThisWeek, &i.LastWeek)
	return i, err
}

const updateLastRemindedAt = `-- name: UpdateLastRemindedAt :exec
UPDATE reminders SET 
    last_reminded_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateLastRemindedAt(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateLastRemindedAt, id)
	return err
}

const updateReminder = `-- name: UpdateReminder :one
UPDATE reminders SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    scheduled_at = COALESCE($4, scheduled_at),
    reminder_type = COALESCE($5, reminder_type),
    notification_channels = COALESCE($6, notification_channels),
    scheduled_time = COALESCE($7, scheduled_time),
    scheduled_days_of_week = COALESCE($8, scheduled_days_of_week),
    delivery_window_minutes = COALESCE($9, delivery_window_minutes),
    delivery_method = COALESCE($10, delivery_method),
    delivery_address = COALESCE($11, delivery_address),
    is_active = COALESCE($12, is_active),
    is_persistent = COALESCE($13, is_persistent),
    reminder_interval_minutes = COALESCE($14, reminder_interval_minutes),
    updated_at = NOW()
WHERE id = $1 RETURNING id, title, description, scheduled_at, delivery_method, delivery_address, status, created_at, updated_at, reminder_type, notification_channels, scheduled_time, scheduled_days_of_week, delivery_window_minutes, is_active, is_persistent, acknowledged_at, reminder_interval_minutes, last_reminded_at, user_id, category, completed_at, completion_note
`

type UpdateReminderParams struct {
	ID                      int32              `json:"id"`
	Title                   string             `json:"title"`
	Description             pgtype.Text        `json:"description"`
	ScheduledAt             pgtype.Timestamptz `json:"scheduled_at"`
	ReminderType            string             `json:"reminder_type"`
	NotificationChannels    []byte             `json:"notification_channels"`
	ScheduledTime           pgtype.Time        `json:"scheduled_time"`
	ScheduledDaysOfWeek     []int32            `json:"scheduled_days_of_week"`
	DeliveryWindowMinutes   int32              `json:"delivery_window_minutes"`
	DeliveryMethod          string             `json:"delivery_method"`
	DeliveryAddress         string             `json:"delivery_address"`
	IsActive                bool               `json:"is_active"`
	IsPersistent            bool               `json:"is_persistent"`
	ReminderIntervalMinutes pgtype.Int4        `json:"reminder_interval_minutes"`
}

func (q *Queries) UpdateReminder(ctx context.Context, arg UpdateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, updateReminder,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ScheduledAt,
		arg.ReminderType,
		arg.NotificationChannels,
		arg.ScheduledTime,
		arg.ScheduledDaysOfWeek,
		arg.DeliveryWindowMinutes,
		arg.DeliveryMethod,
		arg.DeliveryAddress,
		arg.IsActive,
		arg.IsPersistent,
		arg.ReminderIntervalMinutes,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveryMethod,
		&i.DeliveryAddress,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderType,
		&i.NotificationChannels,
		&i.ScheduledTime,
		&i.ScheduledDaysOfWeek,
		&i.DeliveryWindowMinutes,
		&i.IsActive,
		&i.IsPersistent,
		&i.AcknowledgedAt,
		&i.ReminderIntervalMinutes,
		&i.LastRemindedAt,
		&i.UserID,
		&i.Category,
		&i.CompletedAt,
		&i.CompletionNote,
	)
	return i, err
}

const updateReminderCategory = `-- name: UpdateReminderCategory :exec
UPDATE reminders SET 
    category = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReminderCategoryParams struct {
	ID       int32  `json:"id"`
	Category string `json:"category"`
}

func (q *Queries) UpdateReminderCategory(ctx context.Context, arg UpdateReminderCategoryParams) error {
	_, err := q.db.Exec(ctx, updateReminderCategory, arg.ID, arg.Category)
	return err
}

const updateReminderStatus = `-- name: UpdateReminderStatus :exec
UPDATE reminders SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReminderStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateReminderStatus(ctx context.Context, arg UpdateReminderStatusParams) error {
	_, err := q.db.Exec(ctx, updateReminderStatus, arg.ID, arg.Status)
	return err
}
